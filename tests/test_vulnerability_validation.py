

import pytest
import sys
from unittest.mock import MagicMock, patch, Mock

def test_vulnerable_function_with_ssti_payload():
    """
    RED TEST: Directly invokes the vulnerable route with SSTI payload.
    FAILS on vulnerable code (template is evaluated).
    PASSES on secure code (input is escaped/sanitized).
    """
    # Mock all external dependencies
    sys.modules['flask_sqlalchemy'] = MagicMock()
    sys.modules['tornado'] = MagicMock()
    sys.modules['tornado.wsgi'] = MagicMock()
    sys.modules['tornado.httpserver'] = MagicMock()
    sys.modules['tornado.ioloop'] = MagicMock()
    sys.modules['docx'] = MagicMock()
    
    mock_db = MagicMock()
    mock_db.create_all = MagicMock()
    mock_db.session = MagicMock()
    
    with patch('app.app.db', mock_db):
        with patch('app.app.User') as mock_user:
            mock_user.query.first.return_value = MagicMock()
            
            with patch('app.app.Customer') as mock_customer:
                mock_customer.query.first.return_value = MagicMock()
                
                from app.app import app
                from flask import Flask
                
                # Create test request context
                with app.test_request_context():
                    with app.test_client() as client:
                        # SSTI payloads to test
                        test_cases = [
                            ('{{7*7}}', b'49'),
                            ('{{7*\'7\'}}', b'7777777'),
                            ('{{config.SECRET_KEY}}', b'F12Zr47j'),
                        ]
                        
                        for payload, expected_output in test_cases:
                            # Test multiple potential endpoints
                            for path in ['/search', '/profile', '/render', '/user', '/preview']:
                                try:
                                    response = client.post(path, 
                                                          data={'name': payload, 'q': payload, 'input': payload},
                                                          follow_redirects=True)
                                    
                                    if response.status_code not in [404, 405]:
                                        # RED ASSERTION: Template expressions should NOT be evaluated
                                        assert expected_output not in response.data, (
                                            f"SSTI vulnerability at {path}: "
                                            f"Payload '{payload}' was evaluated. "
                                            f"Expected literal text, but got evaluated output. "
                                            f"This proves render_template_string() processes user input unsafely."
                                        )
                                except Exception:
                                    # Endpoint might not exist, continue testing others
                                    pass

def test_jinja2_context_access():
    """
    RED TEST: Proves template injection allows access to request/session context.
    FAILS on vulnerable code.
    PASSES on secure code.
    """
    sys.modules['flask_sqlalchemy'] = MagicMock()
    
    with patch('app.app.db'):
        from app.app import app
        
        with app.test_client() as client:
            # Payload to access Flask request object
            payload = '{{request.environ}}'
            
            response = client.post('/search', data={'q': payload})
            
            # RED ASSERTION: Should not expose request internals
            assert b'environ' not in response.data or b'{{request.environ}}' in response.data, (
                "SSTI vulnerability: Template injection exposes request context"
            )